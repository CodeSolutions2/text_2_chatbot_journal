<!DOCTYPE html>
<html>
<head></head>
<body>    

<h1>Text-to-chatbot webapp</h1>
<ol type="A">
	<li>Input GitHub repository url to file.</li>
	<li>Select method type to create a chatbot: OpenAI Assistant, Q&A finetuning, Q&A finetuning and Vector Similarity.</li>
	<li>View notification or errors about chatbot creation.</li>
	<li>View select text from the file.</li>
	<li>Chat with chatbot about the text in the file.</li>
</ol>

<!-- ---------------------------------------- -->
<!-- View two split window -->
<div align="left">
<table style='text-align: left; width: 500px; display:block'>
<tr>

<th id="inputs">
<h1></h1>

<h3>[Step 0] Input GitHub repository url to file to include in the analysis (ie: https://raw.githubusercontent.com/CodeSolutions2/text_2_chatbot_journal/main/journal_data.txt).</h3>
<input id="file_download_url" type="text" value="" placeholder="file_download_url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
Write a Question or request about the text in the file:
<input id="prompt" type="text" value="" placeholder="prompt" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">

<input type="file" id="upload_file" accept=".txt" style="display:block">
	
<h3>[Step 1] Select method type to create a chatbot</h3>
<select name="chatbot_method_list" id="chatbot_method_list">
<option value="openai_assistant">OpenAI Assistant</option>
<option value="q_and_a_finetuning">Q&A finetuning</option>
<option value="q_and_a_finetuning_vec_sim">Q&A finetuning and Vector Similarity</option>
</select> 

<input id="OPENAI_API_KEY" type="text" value="" placeholder="OPENAI_API_KEY" rows="10" cols="100" style="display:block; text-align: left; width: 150px;">
<br>
<button id="run_selection" onclick="run_selection()">Run Selection</button>
<br>
<h3>[Step 2] View notifications and errors</h3>
<div id="notification"></div>
<div id="error"></div>
<br>
<h3>[Step 3] View Selected text</h3>
<textarea id="selected_text" rows="35" cols="100" placeholder="Selected Text" style="display:block" width:100px; height: 200px;></textarea>
</th>

<!-- ---------------------------------------- -->

<th id="outputs">
<!-- <h3>[Step 4] Chatbot Area</h3> -->
<!-- ---------------------------------------- -->
<!-- View chatbot -->
<!-- <input id="prompt_input" type="text" value="" placeholder="Ask the chatbot a question about the text" rows="10" cols="100" style="display:block; text-align: left;  height: 50px; width:300px;"><button id="use_chatbot" onclick="use_chatbot()">[Step 4] Ask chatbot</button> -->
<!-- <table id="chatbot_output" style='text-align: left; width: 300px; display:block'> -->
<!-- dynamically add rows here -->
</table>
<!-- ---------------------------------------- -->
<!-- Text DOM outputs -->
<div id="output_FILE_ID"></div>
<div id="output_ASSISTANT_ID"></div>
<div id="output_THREAD_ID"></div>
<div id="output_THREAD_MESSAGE_ID"></div>
<div id="output_RUN_ID"></div>
</th>
	
</tr>
</table>
</div>  
<!-- ---------------------------------------- -->


<!-- ---------------------------------------- -->
<!-- CSS -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; height:20px; }
	
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }

table {vertical-align: top; border-collapse: collapse; position: relative; z-index: 0; border: 0px solid black;}

tr {vertical-align: top; border: 0px solid black; padding: 10px 10px; }

th, td {vertical-align: top; border: 0px solid black; padding: 10px; }
th#pdf_viewer_input {width: 100%; }
th#pdf_viewer_output {width: 100%; }
</style>

	  
<!-- --------------------------------------------------- -->	  

	  
<script>

var FILE_ID = "";
var ASSISTANT_ID = "";
var THREAD_ID = "";
var THREAD_MESSAGE_ID = "";
var RUN_ID = "";

var upload_files_filename = "";
var create_an_assistant_assistant_name = "";
var create_an_assistant_description ="";
var create_an_assistant_instructions = "";
var create_a_thread_content ="";
var add_a_message_to_a_thread_content = "";
	
var month = {"01": "january", "02": "february", "03": "march", "04": "april", "05": "may", "06": "june", "07": "july", "08": "august", "09": "september", "10": "october", "11": "november", "12": "december"};


// ----------------------------------------------------
	
// The eventlistener needs to be always running, to detect which file the user selected with browse
document.getElementById("upload_file").addEventListener("change", previewInput, false);

async function previewInput(event) {
	
	// ---------------------
	
	// console.log("event :", event);

	// ---------------------
	
	// Take the first file
	const file = event.target.files[0];  // first file in the list of selected files, better for selecting multiple files at one time
	console.log("file :", file);

	// ---------------------

	const reader = new FileReader();
	reader.onload = function(e){

		base64_string = e.target.result;
		console.log("base64_string:", base64_string);

		// Remove header info (mimeString = "audio/mpeg") because atob can not decode data
		const regex = /data:text/plain;base64,/g;
		base64_string = base64_string.replace(regex, '');
		console.log("base64_string: ", base64_string);

		// Thinking that this should be the text information
		// Decode the Base64-encoded string --> obtain the text data in binary string format
		const binaryString = atob(base64_string);
		console.log("binaryString: ", binaryString);

		
		document.getElementById('selected_text').src = binaryString;
	}
	reader.readAsDataURL(file);

	// ---------------------
}


// ----------------------------------------------------


async function run_selection() {


	// Get the prompt
	var chatbot_method = document.getElementById("chatbot_method_list").value;

	if (chatbot_method == 'openai_assistant') {
		// Step A
		upload_files_filename = document.getElementById("file_download_url").value.split("/").pop();
		console.log("upload_files_filename: ", upload_files_filename);

		// ------------------------

var prompt = document.getElementById("prompt").value; 
	      
	// Step B
	create_an_assistant_assistant_name = "give a response using file";
	create_an_assistant_description = "You are a helpful document content reading and analyzing assistant that responds to content in a file.";
	create_an_assistant_instructions = "You are a helpful document content reading and analyzing assistant that responds to content in a file concisely, using the least number of words. Read the content of a file and respond to the following question: "+prompt+".";
		
	// Step C
	create_a_thread_content = "Read the content of a file and respond to the following request: "+prompt+". Format the output concisely with only the response, use the least number of words.";
		
	// Step D
	add_a_message_to_a_thread_content = "Read the content of a file respond to the following request: "+prompt+". Format the output concisely with only the response, use the least number of words.";
	
		await run_OpenAI_assistant();
	} else if (chatbot_method == 'q_and_a_finetuning') {
		document.getElementById('error').innerHTML = "Not yet connected: in progress";
	} else if (chatbot_method == 'q_and_a_finetuning_vec_sim') {
		document.getElementById('error').innerHTML = "Not yet connected: in progress";
	} else {
		document.getElementById('error').innerHTML = "No chatbot method selected";
      } 
	

}



// ----------------------------------------------------
// Step 2 : dropdown A
// ----------------------------------------------------
async function run_OpenAI_assistant() {

	// Step AA: outputs text to document.getElementById('selected_text')
	await GET_text_from_file_wo_auth_GitHub_RESTAPI()
		// Step A: outputs FILE_ID
		.then(async function() { await upload_files(); })
		// Step B: outputs ASSISTANT_ID
		.then(async function() { await create_an_assistant(); })
		// Step C: outputs THREAD_ID
		.then(async function() { await create_a_thread(); })
		// Step D: outputs THREAD_MESSAGE_ID
		.then(async function() { await add_a_message_to_a_thread(); })
		// Step E: outputs RUN_ID
		.then(async function() {  await run_the_assistant(); })
		// Step F: wait for run to finish
		.then(async function() { await wait_for_run_to_finish(); })
		// Step G
		.then(async function() { await display_the_assistants_response(); })
		.catch(error => { document.getElementById('error').innerHTML = error; });
}

// ----------------------------------------------------
// Step 2 : dropdown B (run_QandA_finetuning)
// ----------------------------------------------------
	
async function run_QandA_finetuning() {
	
	// Read in text data, Display text data in textarea
	await GET_text_from_file_wo_auth_GitHub_RESTAPI()
		// Sort text by timestamp
		.then(async function() {  await sort_text_by_timestamp(transcribed_text) })

		// More steps to add here
	
		.then(async function(text_by_date) { 
			// Processing information
			outp.innerHTML = 'Processing transcribed text';
			// readaudio values are delayed becuse of processing with OpenAI endpoint
			// ----------------------------------------------------
			// Obtain output
			// ----------------------------------------------------
			// [ ***** For debugging Step 3 : do not call model everytime ***** ]
			// return await create_Q_and_As_from_text(text_by_date); 
			// OR
			// Save on using the model: to test other part of the workflow
			return await step1_text_output();
			// ----------------------------------------------------
		})
		.catch(error => { document.getElementById('error').innerHTML = error; });
}



// ----------------------------------------------------
// Step 2 : dropdown C
// ----------------------------------------------------
async function run_QandA_finetuning_vector_sim() {

	// Read in text data, Display text data in textarea
	await GET_text_from_file_wo_auth_GitHub_RESTAPI()
		// Sort text by timestamp
		.then(async function() {  await sort_text_by_timestamp(transcribed_text) })
		
		// More steps to add here
		
		.catch(error => { document.getElementById('error').innerHTML = error; });
}






	
// ----------------------------------------------------
// SUBFUNCTIONS
// ----------------------------------------------------
// ----------------------------------------------------

// Step A
async function upload_files() {
	
	await fetch(document.getElementById("file_download_url").value)
		.then(response => response.blob())
		.then(async function(blob_object) { 
			// Transform blob into a file
			return new File ([blob_object], upload_files_filename, {type: "application/pdf"});
		})
		.then(async function(file_blob_object) { 
			const which_input = 'file_blob_object';  // 'blob_object'
			
			const url = "https://api.openai.com/v1/files";
			const headers = new Headers();
			headers.append("Authorization", 'Bearer ' + document.getElementById("OPENAI_API_KEY").value);
			headers.append("Accept", "application/json");
			const formData = new FormData();
			if (which_input == 'blob_object') {
				// WORKS: but filename is 'blob', one can not specifically name the file
				formData.append("file", file_blob_object);
			} else {
				// file_blob_object: specifically name the file
				formData.append("file", file_blob_object, upload_files_filename);
			}
			formData.append("purpose", "assistants");
			const options = {method: 'POST', 
				       headers: headers, 
				       body: formData,
				       redirect: "follow"};

			return await fetch(url, options);
		})
	 	.then(response => response.json())
	 	.then(async function(result) {
			let output = JSON.parse(JSON.stringify(result));
			FILE_ID = output['id'];
			document.getElementById('output_FILE_ID').innerHTML = FILE_ID;
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP A upload_files finished." })
	 	.catch(error => { document.getElementById('error').innerHTML = error; });
}

// ----------------------------------------------------

// Step B
async function create_an_assistant() {

	// ------------------------------------------

	// Retreive needed variables
	FILE_ID = document.getElementById('output_FILE_ID').innerHTML;

	// ------------------------------------------

	// https://platform.openai.com/docs/api-reference/assistants/createAssistant
	
	var url = 'https://api.openai.com/v1/assistants';
  
	var headers = {"Content-Type": "application/json", 
		       "Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'}

	var data = {"model": "gpt-4-turbo",
		    "name": create_an_assistant_assistant_name, 
		    "description": create_an_assistant_description, 
		    "instructions": create_an_assistant_instructions,
		    "tools": [{"type": "code_interpreter"}],
		    "tool_resources": {"code_interpreter":{"file_ids": [FILE_ID]}},
		    "temperature": 0.02,
		    "top_p": 1
	};
	
	// --------------------
	
	var options = {method : 'POST', headers: headers, body : JSON.stringify(data)};
	
	// ------------------------------------------
	
	await fetch(url, options)
		.then(res => res.json())
		.then(res => { 
			let output = JSON.parse(JSON.stringify(res));
			ASSISTANT_ID = output['id'];
			document.getElementById('output_ASSISTANT_ID').innerHTML = ASSISTANT_ID;
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP B create_an_assistant finished." })
		.catch(error => { document.getElementById('error').innerHTML = error; });
  
}



// ----------------------------------------------------

// Step C
async function create_a_thread() {

	// ------------------------------------------

	// Retreive needed variables
	FILE_ID = document.getElementById('output_FILE_ID').innerHTML;

	// ------------------------------------------
	
	const url = "https://api.openai.com/v1/threads";
	var headers = {"Content-Type": "application/json", 
		       "Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'}

	// ---------------------------

	// File search enables the assistant with knowledge from files that you or your users upload. Once a file is uploaded, the assistant automatically decides when to retrieve content based on user requests.
	
	// Code Interpreter enables the assistant to write and run code. This tool can process files with diverse data and formatting, and generate files such as graphs.
	
	// --------------------
	// Instructions on https://platform.openai.com/docs/assistants/how-it-works/managing-threads-and-messages?lang=python
	var messages = [{"role": "user", "content": create_a_thread_content, "attachments": [{"file_id": FILE_ID, "tools": [{"type": "code_interpreter"}]}]}];
	
	var data = {"messages": messages};
	
	var options = {method : 'POST', headers: headers, body : JSON.stringify(data)};
	
	// ------------------------------------------

	await fetch(url, options)
	 	.then(response => response.json())
	 	.then(async function(result) {
			let output = JSON.parse(JSON.stringify(result));
			THREAD_ID = output['id'];
			document.getElementById('output_THREAD_ID').innerHTML = THREAD_ID;
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP C create_a_thread finished." })
	 	.catch(error => { document.getElementById('error').innerHTML = error; });
	
}
	
// ----------------------------------------------------

// Step D
async function add_a_message_to_a_thread() {

	// ------------------------------------------

  	// Retreive needed variables
	
	THREAD_ID = document.getElementById('output_THREAD_ID').innerHTML;

	// ------------------------------------------
	
	const url = "https://api.openai.com/v1/threads/"+THREAD_ID+"/messages";
	var headers = {"Content-Type": "application/json", 
		       "Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'};
	
	var data = {"role": "user", "content": add_a_message_to_a_thread_content};
	var options = {method : 'post', headers: headers, body : JSON.stringify(data)};

	await fetch(url, options)
	 	.then(response => response.json())
	 	.then(async function(result) {
			let output = JSON.parse(JSON.stringify(result));
			THREAD_MESSAGE_ID = output['id'];
			document.getElementById('output_THREAD_MESSAGE_ID').innerHTML = THREAD_MESSAGE_ID;
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP D add_a_message_to_a_thread finished." })
	 	.catch(error => { document.getElementById('error').innerHTML = error; });
}

// ----------------------------------------------------
  
// Step E
async function run_the_assistant() {

	// ------------------------------------------

	// Retreive needed variables
	THREAD_ID = document.getElementById('output_THREAD_ID').innerHTML;

  	// Retreive needed variables
	ASSISTANT_ID = document.getElementById('output_ASSISTANT_ID').innerHTML;

	// ------------------------------------------
	
	// Create a run such that the assistant reads the thread and decides whether to call tools or use a model to respond to the query.
	// https://platform.openai.com/docs/api-reference/runs/createRun
	
	const url = "https://api.openai.com/v1/threads/"+THREAD_ID+"/runs";
	var headers = {"Content-Type": "application/json", 
		       "Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'};

	// ---------------------------
	// Run original Assistant instructions
	// ---------------------------
	var data = {"assistant_id": ASSISTANT_ID};
	// ---------------------------
	
	var options = {method : 'POST', headers: headers, body : JSON.stringify(data)};
	
	await fetch(url, options)
	 	.then(response => response.json())
	 	.then(async function(result) {
			let output = JSON.parse(JSON.stringify(result));
			RUN_ID = output['id'];
			document.getElementById('output_RUN_ID').innerHTML = RUN_ID;
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP E run_the_assistant finished." })
	 	.catch(error => { document.getElementById('error').innerHTML = error; });

	// Output contains
	// assistant_id, id (which is RUN_ID), instructions, model, status: "queued", temperature, thread_id, tool_choice: "auto", tools: {type: "code_interpreter"}, top_p: 1, truncation_strategy: {type: "auto", last_messages: null}
	
}


// ----------------------------------------------------
  
// Step F
async function check_the_run_status() {

	// ------------------------------------------

	// Retreive needed variables
	THREAD_ID = document.getElementById('output_THREAD_ID').innerHTML;

	// Retreive needed variables
	RUN_ID = document.getElementById('output_RUN_ID').innerHTML;


	// ------------------------------------------

	// https://platform.openai.com/docs/api-reference/runs/getRun
	// GET https://api.openai.com/v1/threads/{thread_id}/runs/{run_id}
	
	const url = "https://api.openai.com/v1/threads/"+THREAD_ID+"/runs/"+RUN_ID;
	var headers = {"Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'};
	var options = {method : 'GET', headers: headers};
	
	return await fetch(url, options)
	 	.then(response => response.json())
	 	.then(async function(result) { return JSON.parse(JSON.stringify(result)); })
	 	.catch(error => { document.getElementById('error').innerHTML = error; });

}


async function wait_for_run_to_finish() {

	document.getElementById('notification').innerHTML = "STEP F wait_for_run_to_finish Processing..."
	
	let flag = 'wait_for_completion';
	let c = 0;
	let max_allowed_loops = 30;

	await check_the_run_status()
		.then(async function(out) {  await new Promise(r => setTimeout(r, 5000)); return out; })
		.then(async function(out) {
			var run_status = out;
				
			while (flag == 'wait_for_completion') {
				if ((run_status.status == "queued" || run_status.status == "in_progress" || run_status.status == "completed") & c < max_allowed_loops) {
					// wait a bit, call run status again
					run_status = await check_the_run_status()
						.then(async function(out) { await new Promise(r => setTimeout(r, 5000)); return out; })
						.then(async function(run_status) {
							if (run_status.status == "completed") { flag = "stop loop"; }; 
							return run_status; 
						});
			
				} else {
					flag = "stop loop";
				}
				// console.log(' c: ', c);
				c = c + 1;
			}
			// console.log(' FINAL: ', run_status.status);
		})
		.then(async function() { document.getElementById('notification').innerHTML = "STEP F wait_for_run_to_finish finished." })
		.catch(error => { document.getElementById('error').innerHTML = error; });
}
  
// ----------------------------------------------------
  
// Step G
async function display_the_assistants_response() {

	// ------------------------------------------

	// Retreive needed variables
	THREAD_ID = document.getElementById('output_THREAD_ID').innerHTML;

	// ------------------------------------------
	
	// https://platform.openai.com/docs/api-reference/messages/listMessages?lang=curl
	// List messages: GET https://api.openai.com/v1/threads/{thread_id}/messages
	
	const url = "https://api.openai.com/v1/threads/"+THREAD_ID+"/messages";
	var headers = {"Content-Type": "application/json", 
		       "Authorization": 'Bearer ' + document.getElementById("OPENAI_API_KEY").value, 
		       "OpenAI-Beta": 'assistants=v2'};
	var options = {method : 'GET', headers: headers};
  
	await fetch(url, options)
	 	.then(response => response.json())
	 	.then(async function(result) {
			let output = JSON.parse(JSON.stringify(result));
			
			document.getElementById('notification').innerHTML = "Assistant Response:";
			document.getElementById('notification').innerHTML += "\n\n";
			output['data'].forEach(async function(row, index){
				let text_output = output['data'][index]['content'][0]['text']['value'];
				if (index == 0) {
					document.getElementById('notification').innerHTML += text_output;
				}
			});
			
		})
		.then(async function() { 
			document.getElementById('notification').innerHTML += "\n\n";
			document.getElementById('notification').innerHTML += "STEP G display_the_assistants_response finished."; 
		})
	 	.catch(error => { document.getElementById('error').innerHTML = error; });

}
	
// ----------------------------------------------------
	
async function GET_text_from_file_wo_auth_GitHub_RESTAPI() {

	var repoOwner = 'CodeSolutions2';
	var repoName = 'text_2_chatbot_journal';
	
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;

	var file_objects = [];
	
	return await fetch(url)
		.then(res => res.json())
		.then(data => { 
			data.forEach(async function(file) {
				var regexp = new RegExp(`${upload_files_filename}`, 'g');
				if (file.type === 'file' && file.name.match(regexp)) {
					file_objects.push(file);
				}
			});
			return file_objects;
		})
		.then(async function (file_objects) {
			var file_object = file_objects.at(0);
			console.log("file_object: ", file_object)
		   
			var file_download_url = file_object.download_url;
			console.log("file_download_url:", file_download_url);
		   
			sha_val = file_object.sha;
			// console.log("sha_val:", sha_val);

			return file_download_url;
		})
		.then(async function (file_download_url) {
			// Way 1: to get text from file
			return await fetch(file_download_url);
		})
		.then(response => response.text())
		.then(async function(text_out) { 
			document.getElementById("selected_text").innerHTML = text_out;  // print in text area
			return text_out;
		})
		.catch(error => { console.log(error); });
}


async function sort_text_by_timestamp(transcribed_text) {
	// Sorting
	const regexp = /[0-9{4}]+_[0-9{2}]+_[0-9{2}]+_[0-9{2}]+_[0-9{2}]+_[0-9{2}]+\n/g; // pattern to look for
	let matches = [...transcribed_text.matchAll(regexp)];
	// console.log('matches: ', matches);
	
	let text_st = 0;
	let text_end = 0;
	let text_by_date = [];
	
	// next: get array of start and end values to cut string
	matches.forEach(async function(row, index) {
		let date = row.at(0);
		// console.log('date: ', date);
		text_st = date.length + text_end;
			
		if (matches.length > (index+1)){
			text_end = matches[index+1].index - 1;
		} else {
			text_end = transcribed_text.length;
		}
		// console.log('text_st: ', text_st, 'text_end: ', text_end);
		text_by_date.push({date: date, text: transcribed_text.slice(text_st, text_end)});
	});
	
	console.log('text_by_date: ', text_by_date);

	// -----------------------------------
	
	// Optional: could sort the Array of dictionaries by date, so it is in chronological order
	
	// -----------------------------------
	
	return text_by_date;
}

	
</script>

  </body>
</html>
